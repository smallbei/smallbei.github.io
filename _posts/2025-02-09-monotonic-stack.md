---
layout: post
title: "单调栈详解：从入门到实践"
date: 2025-02-09
tags: "算法 栈 数据结构"
category: 
---

## 背景介绍

在计算机科学中，我们经常需要解决"找到数组中下一个更大/更小元素"、"寻找数组中的模式"等问题。传统的方法可能需要嵌套循环，时间复杂度达到O(n²)。单调栈的出现为这类问题提供了一个优雅且高效的解决方案。

## 基本概念

### 什么是单调栈？

单调栈是一种特殊的栈结构，其中的元素保持单调递增或单调递减的顺序。与普通栈相比，单调栈在插入新元素时会维护这种单调性，必要时会弹出栈顶元素。

想象一下排队买票的场景：
- 如果要求按身高从矮到高排队（单调递增），当一个高个子来了后发现前面有比他高的，那些人就要让出位置
- 如果要求按身高从高到矮排队（单调递减），当一个矮个子来了后发现前面有比他矮的，那些人就要让出位置

### 单调栈的类型

1. **单调递增栈**
   - 从栈底到栈顶元素单调递增（栈顶最大）
   - 用于找下一个更小的元素
   - 特点：保证栈内元素始终是从小到大排列

2. **单调递减栈**
   - 从栈底到栈顶元素单调递减（栈顶最小）
   - 用于找下一个更大的元素
   - 特点：保证栈内元素始终是从大到小排列

## 工作原理

让我们通过一个生动的例子来理解单调栈的工作原理：

### 单调递增栈的工作流程

以数组 [5, 2, 8, 3, 7] 为例，我们要构建一个单调递增栈：

```
初始状态：[]
1. 遇到 5：
   栈：[5]
   
2. 遇到 2：
   由于 2 < 5，5出栈
   栈：[2]
   
3. 遇到 8：
   由于 8 > 2，直接入栈
   栈：[2, 8]
   
4. 遇到 3：
   由于 3 < 8，8出栈
   栈：[2, 3]
   
5. 遇到 7：
   由于 7 > 3，直接入栈
   栈：[2, 3, 7]

最终栈内元素：[2, 3, 7]（保持递增）
```

### 单调递减栈的工作流程

同样以数组 [5, 2, 8, 3, 7] 为例：

```
初始状态：[]
1. 遇到 5：
   栈：[5]
   
2. 遇到 2：
   由于 2 < 5，直接入栈
   栈：[5, 2]
   
3. 遇到 8：
   由于 8 > 2 且 8 > 5，2和5都出栈
   栈：[8]
   
4. 遇到 3：
   由于 3 < 8，直接入栈
   栈：[8, 3]
   
5. 遇到 7：
   由于 7 > 3，3出栈
   由于 7 < 8，7入栈
   栈：[8, 7]

最终栈内元素：[8, 7]（保持递减）
```

## 实际应用示例

### 1. 股票价格跨度问题

```swift
// 股票价格跨度问题：计算当前股票价格向前看，连续多少天的价格都小于等于今天的价格
class StockSpanner {
    // 存储（价格，跨度）对
    private var stack: [(price: Int, span: Int)] = []
    
    func next(_ price: Int) -> Int {
        var span = 1 // 至少包含今天
        
        // 当栈不为空且栈顶价格小于等于当前价格时
        while let last = stack.last, last.price <= price {
            span += last.span // 累加跨度
            stack.removeLast()
        }
        
        stack.append((price, span))
        return span
    }
}

// 使用示例
let spanner = StockSpanner()
print(spanner.next(100)) // 输出：1
print(spanner.next(80))  // 输出：1
print(spanner.next(60))  // 输出：1
print(spanner.next(70))  // 输出：2
print(spanner.next(60))  // 输出：1
print(spanner.next(75))  // 输出：4
print(spanner.next(85))  // 输出：6
```

### 2. 接雨水问题

这是一个经典的单调栈应用：给定 n 个非负整数表示每个宽度为 1 的柱子的高度，计算按此排列的柱子，下雨之后能接多少雨水。

直观理解：
- 雨水能够存在的前提是有"凹槽"
- "凹槽"需要左右两边都有比中间高的柱子
- 接到的雨水量取决于左右两边较矮的那个柱子的高度

以数组 [0,1,0,2,1,0,1,3,2,1,2,1] 为例：

```
初始状态：
     3
     █
 2   █ █  █
 █ █ ██████
 ████████████
 012345678901

分析每个位置能接的水：
位置2：左边高度1，右边高度2，当前高度0
→ 可以接 min(1,2)-0 = 1 个单位的水

位置5：左边高度1，右边高度1，当前高度0
→ 可以接 min(1,1)-0 = 1 个单位的水

以此类推...

最终的蓄水状态：
     3
     █
 2   █ █  █
 █ █ ██████
 ████████████
 012345678901
   ~ ~  ~    <- 波浪线表示存水
```

让我们用单调栈来解决这个问题：

```swift
func trap(_ height: [Int]) -> Int {
    // 存储柱子的索引和高度
    var stack: [(index: Int, height: Int)] = []
    var water = 0
    
    // 遍历每个柱子
    for (i, h) in height.enumerated() {
        // 当前柱子比栈顶柱子高，可能形成凹槽
        while let last = stack.last, h >= last.height {
            let bottom = stack.removeLast() // 凹槽的底部
            
            // 如果栈空了，说明左边没有更高的柱子，无法形成凹槽
            if let left = stack.last {
                // 计算凹槽的宽度和高度
                let width = i - left.index - 1  // 左右柱子之间的距离
                let height = min(left.height, h) - bottom.height // 取左右两边较矮的高度，减去底部高度
                water += width * height // 累加这个凹槽能接的水
            }
        }
        stack.append((i, h)) // 将当前柱子入栈
    }
    
    return water
}

// 使用示例
let heights = [0,1,0,2,1,0,1,3,2,1,2,1]
print("能接住的雨水量：\(trap(heights))") // 输出：6

/*
让我们一步步看执行过程：

1. 遇到 0：入栈 [(0,0)]

2. 遇到 1：
   1 > 0，可能形成凹槽
   但左边没有更高的柱子，不能接水
   栈：[(1,1)]

3. 遇到 0：
   0 < 1，直接入栈
   栈：[(1,1), (2,0)]

4. 遇到 2：
   2 > 0，计算位置2的水量：
   width = 4-1-1 = 2
   height = min(1,2)-0 = 1
   water += 2*1 = 2
   栈：[(4,2)]

... 以此类推

最终得到的蓄水量为6，其中：
- 位置2可以接1个单位的水
- 位置5可以接1个单位的水
- 位置6可以接2个单位的水
- 位置9可以接1个单位的水
- 位置11可以接1个单位的水

图形表示：
     3
     █
 2   █ █  █     原始柱子
 █ █ ██████
 ████████████
 012345678901
   ~ ~  ~       存水位置（~表示水）
*/
```

这个问题的关键点：

1. **为什么用单调栈？**
   - 我们需要找到能形成"凹槽"的位置
   - 单调栈可以帮我们找到左右两边第一个比当前位置高的柱子

2. **栈中存什么？**
   - 存储(索引，高度)对
   - 索引用于计算凹槽的宽度
   - 高度用于计算凹槽的深度

3. **什么时候计算结果？**
   - 当遇到一个比栈顶更高的柱子时
   - 说明可能形成了一个凹槽，需要计算这个凹槽能接多少水

4. **如何计算每个凹槽的水量？**
   - 宽度 = 右边柱子索引 - 左边柱子索引 - 1
   - 高度 = min(左边柱子高度, 右边柱子高度) - 凹槽底部高度
   - 水量 = 宽度 × 高度

### 3. 每日温度问题（优化版）

这是一个经典的单调栈应用：给定每日温度数组，求对于每一天，需要等待多少天才能遇到一个更暖和的温度。

比如温度数组 [23, 24, 25, 21, 19, 22, 26, 23]：
- 第1天是23度，第2天是24度，需要等待1天
- 第2天是24度，第3天是25度，需要等待1天
- 第3天是25度，需要等到第7天（26度）才遇到更高温度，等待4天
- 以此类推...

让我们用单调栈来解决这个问题：

```swift
func dailyTemperatures(_ temperatures: [Int]) -> [Int] {
    // 结果数组：存储每天需要等待的天数
    var result = Array(repeating: 0, count: temperatures.count)
    // 单调栈：使用单调递减栈，存储（天数，温度）对
    var stack: [(day: Int, temp: Int)] = []
    
    // 遍历每天的温度
    for (today, temp) in temperatures.enumerated() {
        // 当发现更高温度时，说明栈顶的天气找到了「下一个更暖和的天气」
        while let last = stack.last, temp > last.temp {
            let prevDay = stack.removeLast().day
            // 计算等待天数 = 当前天数 - 之前的天数
            result[prevDay] = today - prevDay
        }
        // 将当天温度入栈
        stack.append((today, temp))
    }
    
    return result
}

// 使用示例
let temperatures = [23, 24, 25, 21, 19, 22, 26, 23]
let result = dailyTemperatures(temperatures)
print("等待天数：\(result)") // [1, 1, 4, 2, 1, 1, 0, 0]

/*
让我们一步步看这个例子的执行过程：

1. [23] 入栈
   栈：[(0, 23)]
   
2. 遇到 24
   24 > 23，找到了23的下一个更暖天气
   23出栈，result[0] = 1 - 0 = 1
   24入栈
   栈：[(1, 24)]
   
3. 遇到 25
   25 > 24，找到了24的下一个更暖天气
   24出栈，result[1] = 2 - 1 = 1
   25入栈
   栈：[(2, 25)]
   
4. 遇到 21
   21 < 25，直接入栈
   栈：[(2, 25), (3, 21)]
   
5. 遇到 19
   19 < 21，直接入栈
   栈：[(2, 25), (3, 21), (4, 19)]
   
6. 遇到 22
   22 > 19，19出栈，result[4] = 5 - 4 = 1
   22 > 21，21出栈，result[3] = 5 - 3 = 2
   22 < 25，22入栈
   栈：[(2, 25), (5, 22)]
   
7. 遇到 26
   26 > 22，22出栈，result[5] = 6 - 5 = 1
   26 > 25，25出栈，result[2] = 6 - 2 = 4
   26入栈
   栈：[(6, 26)]
   
8. 遇到 23
   23 < 26，直接入栈
   栈：[(6, 26), (7, 23)]

最终结果：[1, 1, 4, 2, 1, 1, 0, 0]

温度变化图：
26 |           █
25 |     █     
24 |   █       
23 | █           █
22 |         █   
21 |       █     
20 |             
19 |         █   
   +-------------
     0 1 2 3 4 5 6 7
*/
```

这个问题的关键点：

1. **为什么用单调栈？**
   - 我们需要找到每个温度的"下一个更高温度"
   - 单调递减栈正好满足这个需求：栈顶永远是最小的，遇到更高温度时就找到了答案

2. **栈中存什么？**
   - 存储(天数，温度)对而不是单纯的温度
   - 这样可以方便计算等待天数

3. **什么时候计算结果？**
   - 当遇到一个高温度时，说明栈中较低温度的日子找到了"下一个更暖和的天气"
   - 此时计算等待天数 = 当前天数 - 之前的天数

4. **为什么最后一些温度是0？**
   - 因为这些温度后面没有出现更高的温度
   - 它们会留在栈中，对应的结果保持默认值0

## 性能优化技巧

### 1. 预分配容量

```swift
// 预先分配栈的容量，避免频繁扩容
var stack = ContiguousArray<Int>()
stack.reserveCapacity(expectedSize)
```

### 2. 使用值类型优化

```swift
// 使用结构体替代元组，提高可读性和性能
struct StackElement: Comparable {
    let index: Int
    let value: Int
    
    static func < (lhs: StackElement, rhs: StackElement) -> Bool {
        lhs.value < rhs.value
    }
}
```

### 3. 内存优化

```swift
// 使用小内存占用的数据结构
struct CompactStackElement {
    // 使用较小的整数类型
    let index: Int16
    let value: Int16
}
```

## 使用建议

1. **选择合适的单调性**
   - 找下一个更大元素 → 使用单调递减栈
   - 找下一个更小元素 → 使用单调递增栈

2. **处理边界情况**
   - 栈为空时的处理
   - 数组末尾元素的处理
   - 相等元素的处理策略

3. **调试技巧**
   - 使用小规模测试用例
   - 打印栈的变化过程
   - 可视化栈的状态

## 总结

单调栈是一个既简单又强大的数据结构，它通过维护栈的单调性来高效解决特定类型的问题。关键要点：

1. 理解单调性的概念和维护方式
2. 掌握不同类型单调栈的应用场景
3. 熟练运用在实际问题中
4. 注意性能优化和边界处理

通过本文的学习，你应该能够：
- 理解单调栈的工作原理
- 实现基本的单调栈结构
- 运用单调栈解决实际问题
- 优化单调栈的实现

## 练习建议

1. LeetCode相关题目：
   - #739 每日温度
   - #42 接雨水
   - #84 柱状图中最大的矩形
   - #901 股票价格跨度
   - #496 下一个更大元素 I

2. 进阶练习：
   - 尝试实现循环数组中的下一个更大元素
   - 解决带有重复元素的问题
   - 优化空间复杂度

## 参考资源

1. LeetCode相关题目集合
2. 数据结构与算法教程
3. Swift官方文档
4. 算法可视化网站

希望这篇详细的教程能帮助你更好地理解和使用单调栈这一数据结构。记住，实践是掌握算法的最好方式！ 