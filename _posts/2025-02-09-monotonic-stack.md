---
layout: post
title: "单调栈详解：从入门到实践"
date: 2025-02-09
tags: "算法 栈 数据结构"
category: "算法"
---

## 什么是单调栈？

想象你在看一排人站队，每个人都有不同的身高。如果你想知道每个人右边第一个比他高的人是谁，你会怎么做？

传统方法是对每个人都往右看一遍，这样效率很低（时间复杂度O(n²)）。但如果我们用单调栈，就能高效地解决这个问题。

单调栈就是一个特殊的栈，它要求栈中的元素始终保持单调性（递增或递减）。当我们要入栈一个新元素时，会先把所有破坏单调性的栈顶元素都移除。

## 单调栈的两种类型

### 1. 单调递增栈
- 特点：从栈底到栈顶元素严格递增
- 应用：找下一个更小的元素
- 维护规则：新元素入栈前，弹出所有大于它的栈顶元素

### 2. 单调递减栈
- 特点：从栈底到栈顶元素严格递减
- 应用：找下一个更大的元素
- 维护规则：新元素入栈前，弹出所有小于它的栈顶元素

## 图解单调栈工作原理

让我们通过一个简单的例子来理解单调递减栈是如何工作的：

数组：[5, 3, 8, 4, 2, 7]
目标：找到每个元素右边第一个比它大的数

```
步骤1: [5]
        ↑ 当前处理3
步骤2: [5,3]  (3<5，直接入栈)
        ↑ 当前处理8
步骤3: [8]    (8>5和3，弹出5,3后入栈)
        ↑ 当前处理4
步骤4: [8,4]  (4<8，直接入栈)
        ↑ 当前处理2
步骤5: [8,4,2] (2<4，直接入栈)
        ↑ 当前处理7
步骤6: [8,7]  (7>4和2，弹出4,2后入栈)

最终结果：[8,-1,-1,7,7,-1]
```

## 实际应用场景

### 1. 每日温度问题
给定一个温度数组，求对于每一天，需要等几天才能遇到更暖和的温度。

```swift
func dailyTemperatures(_ temperatures: [Int]) -> [Int] {
    // 存储结果：每个温度需要等待的天数
    var result = Array(repeating: 0, count: temperatures.count)
    // 栈存储温度的下标，栈中温度保持单调递减
    var stack: [Int] = []
    
    // 遍历每天的温度
    for today in 0..<temperatures.count {
        // 当前温度大于栈顶温度时，可以更新栈顶温度对应的等待天数
        while let lastDay = stack.last, 
              temperatures[today] > temperatures[lastDay] {
            // 计算等待天数
            result[lastDay] = today - lastDay
            stack.removeLast()
        }
        // 将当天加入栈中
        stack.append(today)
    }
    
    return result
}

// 示例
let temps = [73, 74, 75, 71, 69, 72, 76, 73]
print(dailyTemperatures(temps)) // 输出: [1, 1, 4, 2, 1, 1, 0, 0]

/* 详细解释
第1天: 73度 -> 等1天到74度
第2天: 74度 -> 等1天到75度
第3天: 75度 -> 等4天到76度
第4天: 71度 -> 等2天到72度
第5天: 69度 -> 等1天到72度
第6天: 72度 -> 等1天到76度
第7天: 76度 -> 后面没有更高温度，为0
第8天: 73度 -> 后面没有更高温度，为0
*/
```

### 2. 下一个更大元素
给定一个数组，返回一个等长数组，对应索引存储下一个更大元素，如果没有更大的元素，就存储-1。

```swift
func nextGreaterElement(_ nums: [Int]) -> [Int] {
    var result = Array(repeating: -1, count: nums.count)
    var stack: [Int] = [] // 存储下标
    
    // 从左向右遍历
    for i in 0..<nums.count {
        // 当前元素大于栈顶元素时，更新栈顶元素的下一个更大元素
        while let last = stack.last, nums[i] > nums[last] {
            result[last] = nums[i]
            stack.removeLast()
        }
        stack.append(i)
    }
    
    return result
}

// 示例
let nums = [2, 1, 2, 4, 3]
print(nextGreaterElement(nums)) // 输出: [4, 2, 4, -1, -1]

/* 详细解释
2 -> 4 (下一个更大的是4)
1 -> 2 (下一个更大的是2)
2 -> 4 (下一个更大的是4)
4 -> -1 (没有下一个更大的)
3 -> -1 (没有下一个更大的)
*/
```

## 单调栈的优势

1. **时间效率高**
   - 时间复杂度：O(n)，每个元素最多入栈和出栈一次
   - 避免了传统方法的嵌套循环

2. **空间效率好**
   - 空间复杂度：O(n)
   - 栈中元素个数动态变化，通常远小于n

3. **代码简洁**
   - 实现逻辑清晰
   - 维护规则统一

## 使用技巧

1. **选择合适的单调性**
   - 找下一个更大元素 → 用单调递减栈
   - 找下一个更小元素 → 用单调递增栈

2. **处理特殊情况**
   - 数组为空
   - 重复元素的处理
   - 循环数组的处理

3. **优化建议**
   - 根据具体问题选择存储索引还是元素值
   - 考虑是否需要双向处理（从左到右和从右到左）
   - 合理使用预分配空间优化性能

## 总结

单调栈是一个既简单又强大的数据结构，它通过维护栈的单调性，可以在O(n)时间内解决很多看似需要O(n²)的问题。关键是要：

1. 理解单调性的维护规则
2. 掌握何时使用递增栈或递减栈
3. 熟练运用在实际问题中
4. 注意边界情况的处理

## 练习题推荐

1. LeetCode 739: 每日温度
2. LeetCode 496: 下一个更大元素 I
3. LeetCode 84: 柱状图中最大的矩形
4. LeetCode 901: 股票价格跨度
5. LeetCode 42: 接雨水

通过这些题目的练习，你会对单调栈的应用有更深入的理解。 